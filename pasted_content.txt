import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Button } from './ui/button';
import { Badge } from './ui/badge';

const SymbolectEngine = ({ onSymbolGenerated, naturalLanguageInput }) => {
  const [symbols, setSymbols] = useState([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [confidence, setConfidence] = useState(0);

  // Symbol mapping dictionary
  const symbolMap = {
    'authentication': '🔐',
    'user': '👤',
    'database': '🗄️',
    'api': '🔌',
    'frontend': '🖥️',
    'backend': '⚙️',
    'test': '🧪',
    'security': '🛡️',
    'form': '📝',
    'button': '🔘',
    'login': '🚪',
    'password': '🔑',
    'email': '📧',
    'validation': '✅',
    'error': '❌',
    'success': '✨',
    'loading': '⏳',
    'save': '💾',
    'delete': '🗑️',
    'edit': '✏️',
    'create': '➕',
    'read': '👁️',
    'update': '🔄',
    'search': '🔍',
    'filter': '🔽',
    'sort': '📊',
    'export': '📤',
    'import': '📥'
  };

  const parseNaturalLanguage = async (input) => {
    setIsProcessing(true);
    
    try {
      // Simulate API call to symbolect parser
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const words = input.toLowerCase().split(' ');
      const detectedSymbols = [];
      let confidenceScore = 0;
      
      words.forEach(word => {
        if (symbolMap[word]) {
          detectedSymbols.push({
            symbol: symbolMap[word],
            meaning: word,
            confidence: Math.random() * 0.3 + 0.7 // 0.7-1.0
          });
          confidenceScore += 0.1;
        }
      });
      
      // Add some contextual symbols based on patterns
      if (input.includes('login') || input.includes('auth')) {
        detectedSymbols.push({
          symbol: '🔐→👤',
          meaning: 'authentication_flow',
          confidence: 0.9
        });
      }
      
      if (input.includes('form') && input.includes('submit')) {
        detectedSymbols.push({
          symbol: '📝→💾',
          meaning: 'form_submission',
          confidence: 0.85
        });
      }
      
      setSymbols(detectedSymbols);
      setConfidence(Math.min(confidenceScore, 1.0));
      
      // Generate compressed representation
      const compressed = detectedSymbols.map(s => s.symbol).join('⨹');
      onSymbolGenerated({
        compressed,
        symbols: detectedSymbols,
        confidence: Math.min(confidenceScore, 1.0),
        tokenReduction: Math.floor((input.length - compressed.length) / input.length * 100)
      });
      
    } catch (error) {
      console.error('Symbolect parsing error:', error);
    } finally {
      setIsProcessing(false);
    }
  };

  useEffect(() => {
    if (naturalLanguageInput && naturalLanguageInput.length > 10) {
      parseNaturalLanguage(naturalLanguageInput);
    }
  }, [naturalLanguageInput]);

  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          ⨹ Symbolect Engine
          {isProcessing && <span className="animate-spin">🔄</span>}
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {symbols.length > 0 && (
          <>
            <div className="flex flex-wrap gap-2">
              {symbols.map((symbol, index) => (
                <Badge key={index} variant="secondary" className="text-lg">
                  {symbol.symbol}
                  <span className="ml-1 text-xs">
                    ({Math.floor(symbol.confidence * 100)}%)
                  </span>
                </Badge>
              ))}
            </div>
            
            <div className="grid grid-cols-2 gap-4 text-sm">
              <div>
                <strong>Compression:</strong> {symbols.map(s => s.symbol).join('⨹')}
              </div>
              <div>
                <strong>Confidence:</strong> {Math.floor(confidence * 100)}%
              </div>
            </div>
            
            <div className="text-xs text-muted-foreground">
              Token reduction: ~{Math.floor((naturalLanguageInput?.length || 0) > 0 ? 
                (naturalLanguageInput.length - symbols.map(s => s.symbol).join('').length) / 
                naturalLanguageInput.length * 100 : 0)}%
            </div>
          </>
        )}
        
        {!isProcessing && symbols.length === 0 && naturalLanguageInput && (
          <div className="text-center text-muted-foreground py-4">
            No symbols detected. Try describing a feature with technical terms.
          </div>
        )}
      </CardContent>
    </Card>
  );
};

export default SymbolectEngine;